\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{array}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}

% Page setup
\geometry{left=2.5cm,right=2.5cm,top=3cm,bottom=3cm}
\pagestyle{fancy}
\fancyhf{}
\rhead{PayByFaeAi - Part 1: Architecture \& Core Systems}
\lhead{\leftmark}
\cfoot{\thepage}

% Code listing setup
\lstset{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{green!60!black},
    deletekeywords={...},
    escapeinside={\%*}{*)},
    extendedchars=true,
    frame=single,
    keepspaces=true,
    keywordstyle=\color{blue},
    language=JavaScript,
    morekeywords={*,...},
    numbers=left,
    numbersep=5pt,
    numberstyle=\tiny\color{gray},
    rulecolor=\color{black},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stepnumber=1,
    stringstyle=\color{orange},
    tabsize=2,
    title=\lstname
}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={PayByFaeAi Part 1: Architecture and Core Systems},
    pdfauthor={Development Team}
}

% Title formatting
\titleformat{\section}{\Large\bfseries\color{blue}}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries\color{blue!80}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries\color{blue!60}}{\thesubsubsection}{1em}{}

\title{
    \Huge\textbf{PayByFaeAi}\\
    \Large Part 1: Architecture \& Core Systems\\
    \large Complete Backend Integration \& System Design Guide
}
\author{Development Team}
\date{\today}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}

This document is the first part of the comprehensive PayByFaeAi documentation series, focusing specifically on the application's architecture, core systems, and backend integrations. This guide is designed for developers who need to understand the fundamental structure and system design patterns used throughout the application.

\subsection{Document Series Overview}
This documentation is divided into three focused parts:
\begin{itemize}
    \item \textbf{Part 1}: Architecture \& Core Systems (this document)
    \item \textbf{Part 2}: UI/UX \& Frontend Implementation
    \item \textbf{Part 3}: Security, Deployment \& Development Guide
\end{itemize}

\subsection{What You'll Learn in This Document}
\begin{itemize}
    \item Application architecture and design patterns
    \item Authentication and authorization systems
    \item Face recognition integration
    \item Payment system architecture
    \item API integration patterns
    \item Data management and state handling
    \item Notification system architecture
    \item Auto-pay system implementation
\end{itemize}

\section{Application Architecture Overview}

\subsection{High-Level Architecture}

PayByFaeAi follows a modern mobile application architecture built on React Native with Expo, implementing a service-oriented design pattern with clear separation of concerns:

\begin{lstlisting}[language=bash, caption=Core Architecture Layers]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation Layer                   â”‚
â”‚  (React Native Components, Screens, Navigation)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Business Logic Layer                â”‚
â”‚     (Custom Hooks, Context Providers, Services)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Data Access Layer                   â”‚
â”‚   (API Services, Local Storage, Cache Management)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    External Services                   â”‚
â”‚  (Backend APIs, Stripe, Face Recognition, Push Notifications) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\end{lstlisting}

\subsection{Project Structure}

The application follows a well-organized directory structure optimized for maintainability and scalability:

\begin{lstlisting}[language=bash, caption=Project Directory Structure]
PayByFaeAi/
â”œâ”€â”€ app/                          # Screen components (file-based routing)
â”‚   â”œâ”€â”€ (tabs)/                   # Main tab navigation screens
â”‚   â”‚   â”œâ”€â”€ index.tsx            # Home screen
â”‚   â”‚   â”œâ”€â”€ cards.tsx            # Payment methods management
â”‚   â”‚   â”œâ”€â”€ history.tsx          # Transaction history
â”‚   â”‚   â””â”€â”€ profile.tsx          # User profile and settings
â”‚   â”œâ”€â”€ auth/                    # Authentication screens
â”‚   â”‚   â”œâ”€â”€ login.tsx            # Login screen
â”‚   â”‚   â”œâ”€â”€ register.tsx         # Registration screen
â”‚   â”‚   â””â”€â”€ verification.tsx     # Phone verification
â”‚   â”œâ”€â”€ _layout.tsx              # Root layout with providers
â”‚   â”œâ”€â”€ add-card.tsx             # Add payment method screen
â”‚   â”œâ”€â”€ face-registration.tsx    # Face registration screen
â”‚   â”œâ”€â”€ update-face.tsx          # Face update screen
â”‚   â”œâ”€â”€ autopay-settings.tsx     # Auto-pay configuration
â”‚   â”œâ”€â”€ pin-reset.tsx            # PIN reset functionality
â”‚   â”œâ”€â”€ change-password.tsx      # Password change screen
â”‚   â””â”€â”€ transaction-detail.tsx   # Transaction details screen
â”œâ”€â”€ services/                    # Business logic and API services
â”‚   â”œâ”€â”€ api.ts                   # Main API service
â”‚   â”œâ”€â”€ stripeService.ts         # Stripe payment service
â”‚   â”œâ”€â”€ notificationService.ts   # Push notification service
â”‚   â””â”€â”€ updateService.ts         # App update service
â”œâ”€â”€ hooks/                       # Custom React hooks
â”‚   â”œâ”€â”€ useAuth.ts               # Authentication hook
â”‚   â”œâ”€â”€ useNotifications.ts      # Notification management
â”‚   â””â”€â”€ useUpdates.ts            # Update management
â”œâ”€â”€ constants/                   # Configuration and constants
â”‚   â”œâ”€â”€ api.ts                   # API endpoints configuration
â”‚   â”œâ”€â”€ types.ts                 # TypeScript type definitions
â”‚   â”œâ”€â”€ Colors.ts                # Color scheme
â”‚   â”œâ”€â”€ DesignSystem.ts          # Design system tokens
â”‚   â””â”€â”€ Stripe.ts                # Stripe configuration
â””â”€â”€ components/                  # Reusable UI components
    â”œâ”€â”€ ui/                      # Core UI components
    â””â”€â”€ ...                      # Other component categories
\end{lstlisting}

\subsection{Core Architecture Patterns}

\subsubsection{Service Layer Architecture}
Business logic is separated into dedicated service classes that handle specific domains:

\begin{lstlisting}[language=TypeScript, caption=Service Architecture Pattern]
// Core service pattern used throughout the application
abstract class BaseService {
  protected abstract baseUrl: string;
  protected abstract headers: Record<string, string>;
  
  protected async makeRequest<T>(
    endpoint: string, 
    options?: RequestOptions
  ): Promise<T> {
    // Common request logic, error handling, token management
  }
}

// Specific service implementations
class ApiService extends BaseService {
  // Authentication, user management, transactions
}

class StripeService extends BaseService {
  // Payment processing, card management
}

class NotificationService {
  // Push notifications, background processing
}
\end{lstlisting}

\subsubsection{Context-Based State Management}
Global state management using React Context API with custom hooks:

\begin{lstlisting}[language=TypeScript, caption=Context Architecture]
// Authentication context pattern
interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (data: LoginRequest) => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  logout: () => Promise<void>;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Custom hook for consuming context
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
\end{lstlisting}

\subsubsection{File-Based Routing}
Expo Router's file-based routing system where file structure directly corresponds to navigation:

\begin{lstlisting}[language=bash, caption=File-Based Routing Structure]
app/
â”œâ”€â”€ _layout.tsx                  # Root layout
â”œâ”€â”€ (tabs)/                      # Tab group
â”‚   â”œâ”€â”€ _layout.tsx             # Tab layout
â”‚   â”œâ”€â”€ index.tsx               # /
â”‚   â”œâ”€â”€ cards.tsx               # /cards
â”‚   â”œâ”€â”€ history.tsx             # /history
â”‚   â””â”€â”€ profile.tsx             # /profile
â”œâ”€â”€ auth/                       # Auth group
â”‚   â”œâ”€â”€ _layout.tsx             # Auth layout
â”‚   â”œâ”€â”€ login.tsx               # /auth/login
â”‚   â””â”€â”€ register.tsx            # /auth/register
â”œâ”€â”€ add-card.tsx                # /add-card
â””â”€â”€ face-registration.tsx       # /face-registration
\end{lstlisting}

\section{Authentication System}

\subsection{Authentication Architecture}

The authentication system implements a comprehensive JWT-based authentication with multi-factor verification:

\begin{lstlisting}[language=TypeScript, caption=Authentication Flow Architecture]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Phone Number  â”‚â”€â”€â”€â–¶â”‚   Verification  â”‚â”€â”€â”€â–¶â”‚   Registration  â”‚
â”‚   Collection    â”‚    â”‚   (SMS/Call)    â”‚    â”‚   /Login        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Secure Token  â”‚â—€â”€â”€â”€â”‚   JWT Token     â”‚â—€â”€â”€â”€â”‚   Backend       â”‚
â”‚   Storage       â”‚    â”‚   Generation    â”‚    â”‚   Validation    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\end{lstlisting}

\subsubsection{Registration Process}
\begin{enumerate}
    \item \textbf{Phone Verification}: SMS or voice call verification
    \item \textbf{User Information}: Collection of personal details
    \item \textbf{Security Setup}: Password and PIN configuration
    \item \textbf{Account Creation}: Backend user account creation
    \item \textbf{Automatic Login}: Seamless transition to authenticated state
\end{enumerate}

\subsubsection{Authentication Service Implementation}

\begin{lstlisting}[language=TypeScript, caption=Authentication Service Core Methods]
class ApiService {
  // Registration with phone verification
  async register(data: RegisterRequest): Promise<AuthResponse> {
    const response = await this.api.post(API_ENDPOINTS.REGISTER, data);
    await this.storeAuthTokens(response.data);
    await this.storeUser(response.data.user);
    return response.data;
  }

  // Login with username/password
  async login(data: LoginRequest): Promise<AuthResponse> {
    const response = await this.api.post(API_ENDPOINTS.LOGIN, data);
    await this.storeAuthTokens(response.data);
    await this.storeUser(response.data.user);
    return response.data;
  }

  // Automatic token refresh
  async refreshToken(): Promise<void> {
    const refreshToken = await SecureStore.getItemAsync('refresh_token');
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await this.api.post(API_ENDPOINTS.REFRESH_TOKEN, {
      refresh_token: refreshToken
    });

    const { access_token, refresh_token: newRefreshToken } = response.data;
    
    await SecureStore.setItemAsync('access_token', access_token);
    await SecureStore.setItemAsync('refresh_token', newRefreshToken);
  }

  // Secure logout
  async logout(): Promise<void> {
    try {
      await this.api.post(API_ENDPOINTS.LOGOUT);
    } finally {
      await this.clearAuthTokens();
      await this.clearStoredUser();
    }
  }
}
\end{lstlisting}

\subsection{Token Management System}

\subsubsection{Automatic Token Refresh}
The system implements automatic token refresh to maintain seamless user sessions:

\begin{lstlisting}[language=TypeScript, caption=Token Refresh Interceptor]
// Response interceptor for automatic token refresh
this.api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // Handle 401 errors with token refresh
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (this.isRefreshing) {
        // Queue requests during refresh
        return new Promise((resolve, reject) => {
          this.failedQueue.push({ resolve, reject });
        }).then(() => {
          return this.api(originalRequest);
        });
      }

      originalRequest._retry = true;
      this.isRefreshing = true;

      try {
        await this.refreshToken();
        this.processQueue(null);
        return this.api(originalRequest);
      } catch (refreshError) {
        this.processQueue(refreshError);
        await this.logout();
        throw refreshError;
      } finally {
        this.isRefreshing = false;
      }
    }
    
    return Promise.reject(error);
  }
);
\end{lstlisting}

\subsubsection{Secure Storage Implementation}
All authentication data is stored using Expo SecureStore:

\begin{lstlisting}[language=TypeScript, caption=Secure Storage Methods]
// Token storage methods
private async storeAuthTokens(authData: AuthResponse): Promise<void> {
  await SecureStore.setItemAsync('access_token', authData.access_token);
  await SecureStore.setItemAsync('refresh_token', authData.refresh_token);
  await SecureStore.setItemAsync('token_type', authData.token_type);
  await SecureStore.setItemAsync('expires_in', authData.expires_in.toString());
}

// User data storage
private async storeUser(user: User): Promise<void> {
  await SecureStore.setItemAsync('user_data', JSON.stringify(user));
}

// Secure data retrieval
async getStoredUser(): Promise<User | null> {
  const userData = await SecureStore.getItemAsync('user_data');
  return userData ? JSON.parse(userData) : null;
}

// Complete data cleanup
private async clearAuthTokens(): Promise<void> {
  await SecureStore.deleteItemAsync('access_token');
  await SecureStore.deleteItemAsync('refresh_token');
  await SecureStore.deleteItemAsync('token_type');
  await SecureStore.deleteItemAsync('expires_in');
}
\end{lstlisting}

\section{Face Recognition System}

\subsection{Face Recognition Architecture}

The face recognition system integrates with an external face recognition API to provide secure biometric authentication:

\begin{lstlisting}[language=bash, caption=Face Recognition System Flow]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Camera        â”‚â”€â”€â”€â–¶â”‚   Image         â”‚â”€â”€â”€â–¶â”‚   Face API      â”‚
â”‚   Capture       â”‚    â”‚   Processing    â”‚    â”‚   Registration  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UI State      â”‚â—€â”€â”€â”€â”‚   Local Storage â”‚â—€â”€â”€â”€â”‚   Embedding ID  â”‚
â”‚   Update        â”‚    â”‚   Update        â”‚    â”‚   Generation    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\end{lstlisting}

\subsubsection{Face Registration Implementation}

\begin{lstlisting}[language=TypeScript, caption=Face Registration API Integration]
async registerFace(userId: string, name: string, imageUri: string): Promise<any> {
  console.log('API Service - Starting face registration...');
  
  try {
    // Create FormData for React Native
    const formData = new FormData();
    
    // Add text fields
    formData.append('user_id', userId);
    formData.append('name', name);
    
    // Add file - React Native specific format
    const uriParts = imageUri.split('.');
    const fileType = uriParts[uriParts.length - 1];
    
    formData.append('file', {
      uri: imageUri,
      name: `photo.${fileType}`,
      type: `image/${fileType}`,
    } as any);

    // Get authorization header
    const authHeader = await this.getAuthHeader();
    
    // Use axios for better FormData handling
    const response = await axios({
      method: 'POST',
      url: `${API_BASE_URL}${API_ENDPOINTS.REGISTER_FACE}`,
      data: formData,
      headers: {
        ...(authHeader ? { 'Authorization': authHeader } : {}),
        'Content-Type': 'multipart/form-data',
      },
      timeout: 60000,
    });

    console.log('Face registration successful:', response.data);
    return response.data;
    
  } catch (error: any) {
    console.error('Face registration failed:', error);
    throw new Error(`Face registration failed: ${error.message}`);
  }
}
\end{lstlisting}

\subsubsection{Face Registration Flow}

\begin{enumerate}
    \item \textbf{User Initiation}: User navigates to face registration from profile or home screen
    \item \textbf{Permission Request}: Camera permission request and validation
    \item \textbf{Image Capture}: Direct camera access for photo capture
    \item \textbf{Data Processing}: Image processing and FormData preparation
    \item \textbf{API Communication}: Secure upload to face recognition service
    \item \textbf{Embedding Storage}: Embedding ID generation and storage
    \item \textbf{Status Update}: User face registration status update
    \item \textbf{UI Refresh}: Automatic UI updates to reflect new status
\end{enumerate}

\subsection{Face Registration State Management}

\begin{lstlisting}[language=TypeScript, caption=Face Registration State Flow]
const handleFaceRegistration = async (imageUri: string) => {
  if (!userId || !userName.trim()) {
    showAlert('Error', 'User information is missing', undefined, 'error');
    return;
  }

  setShowProcessingAnimation(true);
  setIsLoading(true);
  
  try {
    // Call the external Face Registration API
    const faceApiResponse = await apiService.registerFace(
      userId, 
      userName.trim(), 
      imageUri
    );
    
    // Extract embedding ID from response
    const embeddingId = faceApiResponse.data?.embedding_id || 
                       faceApiResponse.embedding_id;
    
    if (!embeddingId) {
      throw new Error('Face registration failed - no embedding ID returned');
    }
    
    console.log('Face registration successful! Embedding ID:', embeddingId);
    
    // Update the main backend database with face registration status
    await apiService.updateUserFaceStatus(true);
    
    // Refresh the user context to get updated data
    await refreshUser();
    
    // Verify the update worked
    const updatedUser = await apiService.getStoredUser();
    console.log('Updated user face status:', updatedUser?.has_face_registered);
    
    // Show success modal
    setShowProcessingAnimation(false);
    setShowSuccessModal(true);
    
  } catch (error: any) {
    console.error('Face registration error:', error);
    setShowProcessingAnimation(false);
    showAlert('Registration Failed', error.message, undefined, 'error');
  } finally {
    setIsLoading(false);
  }
};
\end{lstlisting}

\section{Payment System Integration}

\subsection{Stripe Integration Architecture}

The payment system implements PCI-compliant payment processing using Stripe's React Native SDK with a security-first approach:

\begin{lstlisting}[language=bash, caption=Payment System Architecture]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CardField     â”‚â”€â”€â”€â–¶â”‚   Stripe        â”‚â”€â”€â”€â–¶â”‚   PaymentMethod â”‚
â”‚   (Secure Input)â”‚    â”‚   Tokenization  â”‚    â”‚   Token         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Local Storage â”‚â—€â”€â”€â”€â”‚   Backend       â”‚â—€â”€â”€â”€â”‚   Token Storage â”‚
â”‚   Update        â”‚    â”‚   Association   â”‚    â”‚   (Secure)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\end{lstlisting}

\subsubsection{Security-First Payment Architecture}

Key security principles implemented:
\begin{itemize}
    \item \textbf{No Raw Card Data}: Card information never touches application servers
    \item \textbf{Stripe Tokenization}: All sensitive data handled by Stripe's PCI-compliant infrastructure
    \item \textbf{Secure Token Storage}: Only secure tokens stored and transmitted
    \item \textbf{Setup Intent Flow}: Modern Stripe setup for future payments
\end{itemize}

\subsubsection{Stripe Service Implementation}

\begin{lstlisting}[language=TypeScript, caption=Stripe Service Core Methods]
class StripeService {
  private apiBaseUrl: string;
  private authToken: string | null = null;

  constructor() {
    this.apiBaseUrl = STRIPE_CONFIG.API_BASE_URL;
  }

  // Create Setup Intent for card storage
  async createSetupIntent(): Promise<SetupIntentResponse> {
    return this.makeApiCall(STRIPE_ENDPOINTS.CREATE_SETUP_INTENT, {
      method: 'POST',
    });
  }

  // Confirm Setup Intent and save card
  async confirmSetupIntent(setupIntentId: string): Promise<any> {
    return this.makeApiCall(
      `${STRIPE_ENDPOINTS.CONFIRM_SETUP_INTENT}/${setupIntentId}`, 
      {
        method: 'POST',
      }
    );
  }

  // Retrieve saved payment methods
  async getPaymentMethods(): Promise<PaymentMethod[]> {
    return this.makeApiCall(STRIPE_ENDPOINTS.GET_PAYMENT_METHODS);
  }

  // Remove payment method
  async deletePaymentMethod(paymentMethodId: string): Promise<void> {
    return this.makeApiCall(
      `${STRIPE_ENDPOINTS.DELETE_PAYMENT_METHOD}?payment_method_id=${paymentMethodId}`, 
      {
        method: 'DELETE',
      }
    );
  }

  // Common API call method with error handling
  private async makeApiCall(endpoint: string, options: RequestInit = {}) {
    if (!this.authToken) {
      throw new Error('No auth token provided');
    }

    const url = `${this.apiBaseUrl}${endpoint}`;
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.authToken}`,
        ...options.headers,
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ 
        detail: 'Unknown error' 
      }));
      throw new Error(errorData.detail || `HTTP ${response.status}`);
    }

    return await response.json();
  }
}
\end{lstlisting}

\subsection{Payment Method Addition Flow}

\begin{lstlisting}[language=TypeScript, caption=Secure Payment Method Addition]
// Hook for secure payment method addition
export const useStripePayments = () => {
  const { confirmSetupIntent } = useStripe();

  const addPaymentMethod = async (authToken: string) => {
    try {
      // Set authentication token
      stripeService.setAuthToken(authToken);

      // Step 1: Create Setup Intent on backend
      const setupIntentResponse = await stripeService.createSetupIntent();

      // Step 2: Confirm Setup Intent with Stripe (handles card tokenization)
      const { setupIntent } = await confirmSetupIntent(
        setupIntentResponse.client_secret,
        {
          paymentMethodType: 'Card',
        }
      );

      if (setupIntent?.status === 'Succeeded') {
        // Step 3: Confirm on backend and save payment method
        const result = await stripeService.confirmSetupIntent(
          setupIntentResponse.setup_intent_id
        );
        
        if (result.success) {
          return result.payment_method;
        } else {
          throw new StripeServiceError('Failed to save payment method');
        }
      } else {
        throw new StripeServiceError('Card setup failed');
      }
    } catch (error) {
      console.error('Error adding payment method:', error);
      throw new StripeServiceError(
        error instanceof Error ? error.message : 'Unknown error occurred'
      );
    }
  };

  return { addPaymentMethod };
};
\end{lstlisting}

\section{API Integration and Data Management}

\subsection{Centralized API Service Architecture}

The application uses a centralized API service class for all backend communications with comprehensive error handling and request management:

\begin{lstlisting}[language=TypeScript, caption=API Service Base Architecture]
class ApiService {
  private api: AxiosInstance;
  private isRefreshing: boolean = false;
  private failedQueue: Array<{
    resolve: (value?: any) => void;
    reject: (error?: any) => void;
  }> = [];

  constructor() {
    this.api = axios.create({
      baseURL: API_BASE_URL,
      timeout: 60000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor for token attachment
    this.api.interceptors.request.use(
      async (config) => {
        console.log(`ğŸš€ API Request: ${config.method?.toUpperCase()} ${config.url}`);
        const token = await SecureStore.getItemAsync('access_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => {
        console.error('âŒ API Request Error:', error);
        return Promise.reject(error);
      }
    );

    // Response interceptor for error handling and token refresh
    this.api.interceptors.response.use(
      (response: AxiosResponse) => {
        console.log(`âœ… API Response: ${response.status} ${response.config.url}`);
        return response;
      },
      async (error) => {
        return this.handleResponseError(error);
      }
    );
  }
}
\end{lstlisting}

\subsection{API Endpoints Configuration}

\begin{lstlisting}[language=TypeScript, caption=Comprehensive API Endpoints]
export const API_ENDPOINTS = {
  // Authentication endpoints
  REGISTER: '/customer/auth/register-frontend',
  LOGIN: '/customer/auth/login',
  REFRESH_TOKEN: '/customer/auth/refresh',
  LOGOUT: '/customer/auth/logout',
  FORGOT_PASSWORD_REQUEST: '/customer/auth/forgot-password/request',
  FORGOT_PASSWORD_VERIFY: '/customer/auth/forgot-password/verify',
  PIN_RESET: '/customer/auth/pin-reset',
  
  // Verification endpoints
  SEND_VERIFICATION: '/customer/verification/send-phone-code',
  VERIFY_CODE: '/customer/verification/verify-phone-code',
  
  // User management endpoints
  GET_PROFILE: '/customer/users/me',
  UPDATE_PUSH_TOKEN: '/customer/users/me/push-token',
  GET_FACE_STATUS: '/customer/users/me/face-status',
  UPDATE_FACE_STATUS: '/customer/users/me/face-status',
  DELETE_FACE_ENROLLMENT: '/customer/users/me/face-enrollment',
  
  // Face recognition endpoints (proxied through backend)
  REGISTER_FACE: '/customer/face/register',
  UPDATE_FACE: '/customer/face/update',
  DELETE_FACE: '/customer/face/delete',
  
  // Payment method endpoints
  GET_PAYMENT_METHODS: '/customer/users/me/payment-methods',
  UPDATE_PAYMENT_METHOD: '/customer/users/me/payment-methods',
  DELETE_PAYMENT_METHOD: '/customer/users/me/payment-methods',
  SET_DEFAULT_PAYMENT_METHOD: '/customer/users/me/payment-methods',
  CREATE_SETUP_INTENT: '/customer/users/me/payment-methods/setup-intent',
  CONFIRM_SETUP_INTENT: '/customer/users/me/payment-methods/confirm-setup-intent',
  ADD_PAYMENT_METHOD_SECURE: '/customer/users/me/payment-methods/secure',
  
  // Auto-pay endpoints
  GET_AUTO_PAY: '/customer/users/me/autopay',
  ADD_AUTO_PAY: '/customer/users/me/autopay',
  UPDATE_AUTO_PAY: '/customer/users/me/autopay',
  DELETE_AUTO_PAY: '/customer/users/me/autopay',
  
  // Transaction endpoints
  GET_TRANSACTIONS: '/customer/users/me/transactions',
  
  // Payment processing endpoints
  APPROVE_PAYMENT: '/customer/users/me/payments',
  DECLINE_PAYMENT: '/customer/users/me/payments',
  
  // Payment request endpoints
  GET_PAYMENT_REQUESTS: '/customer/users/me/payment-requests/',
};
\end{lstlisting}

\subsection{Data Models and Type Definitions}

\begin{lstlisting}[language=TypeScript, caption=Core Data Models]
// User model
export interface User {
  id: string;
  phone_number: string;
  first_name: string;
  last_name: string;
  email?: string;
  is_verified?: boolean;
  has_face_registered: boolean;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

// Payment method model
export interface PaymentMethod {
  id: string;
  user_id: string;
  stripe_payment_method_id: string;
  card_last_four: string;
  card_brand: string;
  card_exp_month: number;
  card_exp_year: number;
  is_default: boolean;
  created_at: string;
  updated_at: string;
}

// Transaction model with detailed information
export interface TransactionDetail {
  id: string;
  user_id: string;
  merchant_id: string;
  merchant_name: string;
  amount: number;
  currency: string;
  status: 'pending' | 'completed' | 'failed' | 'cancelled';
  payment_method_id: string;
  stripe_payment_intent_id?: string;
  description?: string;
  is_auto_paid: boolean;
  created_at: string;
  updated_at: string;
  payment_method?: {
    card_brand: string;
    card_last_four: string;
    card_exp_month: number;
    card_exp_year: number;
  };
  fees?: {
    stripe_fee: number;
    platform_fee: number;
    total_fees: number;
  };
}

// Payment request model
export interface PaymentRequest {
  id: string;
  user_id: string;
  merchant_name: string;
  merchant_id: string;
  business_name?: string;
  amount: number;
  currency: string;
  description?: string;
  status: 'pending' | 'approved' | 'declined' | 'expired';
  expires_at: string;
  created_at: string;
  updated_at: string;
}

// Auto-pay configuration model
export interface AutoPay {
  id: string;
  user_id: string;
  merchant_id: string;
  merchant_name: string;
  is_enabled: boolean;
  max_amount?: number;
  payment_method_id: string;
  created_at: string;
  updated_at: string;
}

// API response wrapper
export interface ApiResponse<T> {
  data?: T;
  message: string;
  error?: string;
  status_code?: number;
}
\end{lstlisting}

\section{Notification System Architecture}

\subsection{Notification Service Design}

The notification system provides real-time alerts for payment activities with comprehensive background processing:

\begin{lstlisting}[language=TypeScript, caption=Notification Service Architecture]
class NotificationService {
  private expoPushToken: string | null = null;

  async initialize() {
    await this.registerForPushNotifications();
    this.setupNotificationHandlers();
    this.setupNotificationChannels();
  }

  private async registerForPushNotifications() {
    // Device validation
    if (!Device.isDevice) {
      console.log('Must use physical device for Push Notifications');
      return;
    }

    // Permission handling
    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;

    if (existingStatus !== 'granted') {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }

    if (finalStatus !== 'granted') {
      console.log('Failed to get push token for push notification!');
      return;
    }

    try {
      // Get Expo push token
      const token = await Notifications.getExpoPushTokenAsync({
        projectId: '9e1f0d76-0db2-4b5e-b263-3fb11c9e737b',
      });
      
      this.expoPushToken = token.data;
      console.log('Expo push token:', this.expoPushToken);
      
      // Send token to backend server
      await this.sendTokenToBackend(this.expoPushToken);
      
    } catch (error) {
      console.error('Failed to get push token:', error);
    }
  }

  // Notification type handlers
  async notifyPaymentRequest(data: PaymentNotificationData) {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Payment Request',
        body: `${data.merchantName} is requesting $${data.amount}`,
        data: { type: 'payment_request', ...data },
        sound: true,
        priority: Notifications.AndroidImportance.HIGH,
      },
      trigger: null,
    });
  }

  async notifyAutoPaymentProcessed(data: PaymentNotificationData) {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Auto Payment Processed',
        body: `$${data.amount} paid to ${data.merchantName}`,
        data: { type: 'auto_payment', ...data },
        sound: true,
        priority: Notifications.AndroidImportance.DEFAULT,
      },
      trigger: null,
    });
  }

  async notifyPaymentApproved(data: PaymentNotificationData) {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Payment Approved',
        body: `Payment of $${data.amount} to ${data.merchantName} was successful`,
        data: { type: 'payment_approved', ...data },
        sound: true,
        priority: Notifications.AndroidImportance.DEFAULT,
      },
      trigger: null,
    });
  }
}
\end{lstlisting}

\subsection{Background Processing System}

\begin{lstlisting}[language=TypeScript, caption=Background Notification Processing]
export const useNotifications = () => {
  const { user, isAuthenticated } = useAuth();
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const previousPaymentRequestIds = useRef<string[]>([]);

  // Main processing function
  const checkForNewPaymentRequests = async () => {
    if (!isAuthenticated || !user) return;

    try {
      // Fetch current payment requests and auto-pay settings
      const [requests, autoPaySettings] = await Promise.all([
        apiService.getPaymentRequests(),
        apiService.getAutoPay().catch(() => [])
      ]);

      const pendingRequests = requests.filter(request => 
        request.status === 'pending'
      );
      const currentRequestIds = pendingRequests.map(req => req.id);
      
      // Identify new requests
      const newRequests = pendingRequests.filter(
        req => !previousPaymentRequestIds.current.includes(req.id)
      );

      // Update tracking reference
      previousPaymentRequestIds.current = currentRequestIds;

      // Process each new request
      for (const request of newRequests) {
        const isAutoPayMerchant = autoPaySettings.find(autoPay => 
          autoPay.merchant_name.toLowerCase() === 
          getDisplayName(request).toLowerCase() && 
          autoPay.is_enabled &&
          (autoPay.max_amount ? autoPay.max_amount >= request.amount : false)
        );

        if (isAutoPayMerchant) {
          try {
            // Auto-approve the payment
            await apiService.approvePayment(request.id);
            await notificationService.notifyAutoPaymentProcessed({
              merchantName: getDisplayName(request),
              amount: request.amount,
              paymentId: request.id,
            });
          } catch (autoPayError) {
            console.error('Auto-payment failed:', autoPayError);
            // Fallback to manual request notification
            await notificationService.notifyPaymentRequest({
              merchantName: getDisplayName(request),
              amount: request.amount,
              requestId: request.id,
              paymentId: request.id,
              isAutoPayMerchant: false,
            });
          }
        } else {
          // Send notification for manual approval
          await notificationService.notifyPaymentRequest({
            merchantName: getDisplayName(request),
            amount: request.amount,
            requestId: request.id,
            paymentId: request.id,
            isAutoPayMerchant: false,
          });
        }
      }
    } catch (error) {
      console.error('Error checking for payment requests:', error);
    }
  };

  // Periodic check management
  const startPeriodicCheck = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    
    intervalRef.current = setInterval(() => {
      checkForNewPaymentRequests();
    }, 30000); // Check every 30 seconds
  };

  const stopPeriodicCheck = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  return {
    checkForNewPaymentRequests,
    startPeriodicCheck,
    stopPeriodicCheck,
  };
};
\end{lstlisting}

\section{Auto-Pay System Implementation}

\subsection{Auto-Pay Architecture}

The auto-pay system enables users to configure automatic payment approval for trusted merchants with comprehensive safety controls:

\begin{lstlisting}[language=bash, caption=Auto-Pay System Flow]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Payment       â”‚â”€â”€â”€â–¶â”‚   Auto-Pay      â”‚â”€â”€â”€â–¶â”‚   Amount        â”‚
â”‚   Request       â”‚    â”‚   Merchant      â”‚    â”‚   Validation    â”‚
â”‚   Received      â”‚    â”‚   Matching      â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Success       â”‚â—€â”€â”€â”€â”‚   Automatic     â”‚â—€â”€â”€â”€â”‚   Approval      â”‚
â”‚   Notification  â”‚    â”‚   Payment       â”‚    â”‚   Process       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Fallback to   â”‚
                    â”‚   Manual        â”‚
                    â”‚   Approval      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\end{lstlisting}

\subsubsection{Auto-Pay Configuration Model}

\begin{lstlisting}[language=TypeScript, caption=Auto-Pay Configuration Structure]
export interface CreateAutoPayRequest {
  merchant_id: string;
  merchant_name: string;
  payment_method_id: string;
  max_amount: number;
}

export interface AutoPay {
  id: string;
  user_id: string;
  merchant_id: string;
  merchant_name: string;
  is_enabled: boolean;
  max_amount?: number;
  payment_method_id: string;
  created_at: string;
  updated_at: string;
}
\end{lstlisting}

\subsubsection{Auto-Pay Processing Logic}

\begin{lstlisting}[language=TypeScript, caption=Auto-Pay Decision Engine]
const processAutoPayDecision = (
  request: PaymentRequest, 
  autoPaySettings: AutoPay[]
): boolean => {
  
  // Find matching auto-pay configuration
  const matchingAutoPay = autoPaySettings.find(autoPay => {
    // Merchant name matching (case-insensitive)
    const merchantMatch = autoPay.merchant_name.toLowerCase() === 
                         request.merchant_name.toLowerCase();
    
    // Auto-pay must be enabled
    const isEnabled = autoPay.is_enabled;
    
    // Amount validation (if limit is set)
    const amountValid = autoPay.max_amount ? 
                       autoPay.max_amount >= request.amount : 
                       true;
    
    return merchantMatch && isEnabled && amountValid;
  });

  return !!matchingAutoPay;
};

// Auto-pay execution with error handling
const executeAutoPay = async (request: PaymentRequest) => {
  try {
    console.log(`Executing auto-pay for ${request.merchant_name}: $${request.amount}`);
    
    // Approve payment automatically
    await apiService.approvePayment(request.id);
    
    // Send success notification
    await notificationService.notifyAutoPaymentProcessed({
      merchantName: request.merchant_name,
      amount: request.amount,
      paymentId: request.id,
    });
    
    console.log('Auto-pay successful');
    
  } catch (error) {
    console.error('Auto-pay failed:', error);
    
    // Fallback to manual approval notification
    await notificationService.notifyPaymentRequest({
      merchantName: request.merchant_name,
      amount: request.amount,
      requestId: request.id,
      paymentId: request.id,
      isAutoPayMerchant: false,
    });
    
    throw error;
  }
};
\end{lstlisting}

\section{Conclusion}

This document has covered the core architecture and system design of the PayByFaeAi application, providing a comprehensive understanding of:

\begin{itemize}
    \item Application architecture patterns and project structure
    \item Authentication system with JWT and secure storage
    \item Face recognition integration and biometric security
    \item Payment system architecture with Stripe integration
    \item API service design and data management
    \item Notification system with background processing
    \item Auto-pay system implementation and decision logic
\end{itemize}

\subsection{Key Architectural Principles}

The application follows several key architectural principles:
\begin{itemize}
    \item \textbf{Separation of Concerns}: Clear separation between presentation, business logic, and data layers
    \item \textbf{Security First}: Comprehensive security measures throughout all systems
    \item \textbf{Service-Oriented Design}: Modular services for different business domains
    \item \textbf{Error Resilience}: Comprehensive error handling and fallback mechanisms
    \item \textbf{Scalable Architecture}: Designed for future growth and feature additions
\end{itemize}

\subsection{Next Steps}

To continue your understanding of the PayByFaeAi application, proceed to:
\begin{itemize}
    \item \textbf{Part 2}: UI/UX \& Frontend Implementation - Detailed coverage of user interface, components, and user experience design
    \item \textbf{Part 3}: Security, Deployment \& Development Guide - Security implementation, deployment processes, and development workflows
\end{itemize}

This architectural foundation provides the necessary understanding to work with the core systems and integrate new features effectively.

\end{document}